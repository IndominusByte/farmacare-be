package handler_http

import (
	"context"
	"encoding/json"
	"log"
	"math"
	"net/http"
	"time"

	_ "github.com/IndominusByte/farmacare-be/api/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/creent-production/cdk-go/parser"
	"github.com/creent-production/cdk-go/response"
	"github.com/creent-production/cdk-go/validation"
	httpSwagger "github.com/swaggo/http-swagger"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

const (
	ResourceNotFound = "Resource not found."
	FailedParseBody  = "Invalid input type."
	// Key Response
	Header = "_header"
	Body   = "_body"
	App    = "_app"
)

type QueryParamAllPokemonSchema struct {
	Page    int    `schema:"page" validate:"required,gte=1"`
	PerPage int    `schema:"per_page" validate:"required,gte=1"`
	OrderBy string `schema:"order_by" validate:"omitempty,oneof=asc desc"`
}

type QueryParamAllBattleSchema struct {
	Page          int    `schema:"page" validate:"required,gte=1"`
	PerPage       int    `schema:"per_page" validate:"required,gte=1"`
	StartDatetime string `schema:"start_datetime" validate:"required,datetimezone=wita-none"`
	EndDatetime   string `schema:"end_datetime" validate:"required,datetimefield=gte-StartDatetime"`
}

type JsonPokemonCheatingSchema struct {
	Name string `json:"name" validate:"required,min=3,max=100"`
}

type Server struct {
	Router     *http.ServeMux
	Db         *mongo.Database
	Collection *mongo.Collection
	Ctx        context.Context
}

func CreateNewServer() Server {
	clientOptions := options.Client().ApplyURI("mongodb://user:pass@mongodb:27017/")
	client, err := mongo.Connect(context.TODO(), clientOptions)
	if err != nil {
		log.Fatal(err)
	}

	err = client.Ping(context.TODO(), nil)
	if err != nil {
		log.Fatal(err)
	}

	return Server{
		Router:     http.NewServeMux(),
		Db:         client.Database("poke"),
		Collection: &mongo.Collection{},
		Ctx:        context.TODO(),
	}
}

func (s *Server) MountHandlers() error {
	s.Router.Handle("/swagger/", httpSwagger.Handler(
		httpSwagger.URL("doc.json"), //The url pointing to API definition
	))
	s.Router.HandleFunc("/pokemons", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case "GET":
			var p QueryParamAllPokemonSchema

			if err := validation.ParseRequest(&p, r.URL.Query()); err != nil {
				response.WriteJSONResponse(w, 422, nil, map[string]interface{}{
					Body: FailedParseBody,
				})
				return
			}

			if err := validation.StructValidate(p); err != nil {
				response.WriteJSONResponse(w, 422, nil, err)
				return
			}

			s.Collection = s.Db.Collection("pokemons")

			findOptions := options.Find()
			if len(p.OrderBy) > 0 {
				if p.OrderBy == "asc" {
					findOptions.SetSort(bson.M{"score": 1})
				} else {
					findOptions.SetSort(bson.M{"score": -1})
				}
			}
			findOptions.SetSkip((int64(p.Page) - 1) * int64(p.PerPage))
			findOptions.SetLimit(int64(p.PerPage))

			total, _ := s.Collection.CountDocuments(s.Ctx, bson.M{})

			var pokemons []Pokemon
			cursor, _ := s.Collection.Find(s.Ctx, bson.M{}, findOptions)
			defer cursor.Close(s.Ctx)

			for cursor.Next(s.Ctx) {
				var pokemon Pokemon
				cursor.Decode(&pokemon)
				pokemons = append(pokemons, pokemon)
			}

			response.WriteJSONResponse(w, 200, map[string]interface{}{
				"data":      pokemons,
				"total":     total,
				"page":      p.Page,
				"last_page": math.Ceil(float64(total) / float64(p.PerPage)),
			}, nil)
		default:
			response.WriteJSONResponse(w, 404, nil, map[string]interface{}{
				App: ResourceNotFound,
			})
		}
	})
	s.Router.HandleFunc("/battle", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case "GET":
			s.Collection = s.Db.Collection("pokemons")
			cursor, _ := s.Collection.Aggregate(s.Ctx, bson.A{bson.M{"$sample": bson.M{"size": 5}}})
			defer cursor.Close(s.Ctx)

			var pokemons []Pokemon
			for cursor.Next(s.Ctx) {
				var pokemon Pokemon
				cursor.Decode(&pokemon)
				pokemons = append(pokemons, pokemon)
			}

			pokemonsOut := SimulateBattle(pokemons)
			pokemonsOut.BattleAt = primitive.NewDateTimeFromTime(time.Now())
			for _, val := range pokemonsOut.PokemonScore {
				var poke Pokemon
				s.Collection.FindOne(s.Ctx, bson.M{"name": val.Name}).Decode(&poke)
				s.Collection.UpdateOne(s.Ctx,
					bson.M{"name": val.Name},
					bson.M{"$set": bson.M{"score": poke.Score + val.Score, "total_match": poke.TotalMatch + 1}})
			}

			s.Collection = s.Db.Collection("battles")
			res, _ := s.Collection.InsertOne(s.Ctx, bson.M{
				"battle_at":      pokemonsOut.BattleAt,
				"pokemon_score":  pokemonsOut.PokemonScore,
				"battle_history": pokemonsOut.BattleHistory,
			})
			pokemonsOut.Id = res.InsertedID.(primitive.ObjectID)

			response.WriteJSONResponse(w, 200, pokemonsOut, nil)
		default:
			response.WriteJSONResponse(w, 404, nil, map[string]interface{}{
				App: ResourceNotFound,
			})
		}
	})
	s.Router.HandleFunc("/battle-history", func(w http.ResponseWriter, r *http.Request) {
		var p QueryParamAllBattleSchema

		if err := validation.ParseRequest(&p, r.URL.Query()); err != nil {
			response.WriteJSONResponse(w, 422, nil, map[string]interface{}{
				Body: FailedParseBody,
			})
			return
		}

		if err := validation.StructValidate(p); err != nil {
			response.WriteJSONResponse(w, 422, nil, err)
			return
		}

		s.Collection = s.Db.Collection("battles")

		findOptions := options.Find()
		findOptions.SetSkip((int64(p.Page) - 1) * int64(p.PerPage))
		findOptions.SetLimit(int64(p.PerPage))

		loc, _ := time.LoadLocation("Asia/Ujung_Pandang")
		layoutFormat := "2006-01-02 15:04:05"
		startTime, _ := time.ParseInLocation(layoutFormat, p.StartDatetime, loc)
		endTime, _ := time.ParseInLocation(layoutFormat, p.EndDatetime, loc)

		filter := bson.M{
			"battle_at": bson.M{"$gte": primitive.NewDateTimeFromTime(startTime), "$lt": primitive.NewDateTimeFromTime(endTime)},
		}

		total, _ := s.Collection.CountDocuments(s.Ctx, bson.M{})

		var pokemons []PokemonOut
		cursor, _ := s.Collection.Find(s.Ctx, filter, findOptions)
		defer cursor.Close(s.Ctx)

		for cursor.Next(s.Ctx) {
			var pokemon PokemonOut
			cursor.Decode(&pokemon)
			pokemons = append(pokemons, pokemon)
		}

		response.WriteJSONResponse(w, 200, map[string]interface{}{
			"data":      pokemons,
			"total":     total,
			"page":      p.Page,
			"last_page": math.Ceil(float64(total) / float64(p.PerPage)),
		}, nil)
	})
	s.Router.HandleFunc("/pokemon-cheating/", func(w http.ResponseWriter, r *http.Request) {
		battleId, _ := parser.ParsePathToStr("/pokemon-cheating/(.*)", r.URL.Path)

		var p JsonPokemonCheatingSchema

		if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
			response.WriteJSONResponse(w, 422, nil, map[string]interface{}{
				Body: FailedParseBody,
			})
			return
		}

		if err := validation.StructValidate(p); err != nil {
			response.WriteJSONResponse(w, 422, nil, err)
			return
		}

		s.Collection = s.Db.Collection("battles")

		var poke PokemonOut

		objectId, _ := primitive.ObjectIDFromHex(battleId)
		err := s.Collection.FindOne(s.Ctx, bson.M{"_id": objectId, "pokemon_score.name": p.Name}).Decode(&poke)
		if err != nil {
			if err == mongo.ErrNoDocuments {
				response.WriteJSONResponse(w, 404, nil, map[string]interface{}{
					Body: "Battle not found.",
				})
				return
			}
		}

		score, scoreMinus := 0, 0
		s.Collection = s.Db.Collection("pokemons")

		for i := 0; i < len(poke.PokemonScore); i++ {
			po := &poke.PokemonScore[i]
			if po.Name == p.Name {
				score = po.Score
				scoreMinus = 1 - po.Score
				po.Score = 1
				s.Collection.UpdateOne(s.Ctx, bson.M{"name": po.Name}, bson.M{"$inc": bson.M{"score": scoreMinus}})
			}
		}

		for i := 0; i < len(poke.PokemonScore); i++ {
			po := &poke.PokemonScore[i]
			if po.Name != p.Name && score > po.Score {
				po.Score += 1
				s.Collection.UpdateOne(s.Ctx, bson.M{"name": po.Name}, bson.M{"$inc": bson.M{"score": 1}})
			}
		}

		s.Collection = s.Db.Collection("battles")
		s.Collection.UpdateOne(s.Ctx, bson.M{"_id": objectId}, bson.M{"$set": bson.M{"pokemon_score": poke.PokemonScore}})

		response.WriteJSONResponse(w, 200, poke.PokemonScore, nil)
	})

	return nil
}
